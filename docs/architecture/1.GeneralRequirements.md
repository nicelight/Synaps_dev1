
# Архитектура проекта "Synaps" и требования по разработке кода. 
**1. Архитектура проекта ориентирована на безопасность изменений кода** при генерации кода LLM моделью: тонкие фасады + pure domain + контракт-first + Spec Driven Dev  + CI + small-PRs.
**2. Архитектура проекта должна обладать Низкой связанностью (low coupling):**
 * Каждый модуль/фасад имеет отдельную ответственность.
 * Сервисы и домен не знают про инфраструктуру напрямую — используют фасады и интерфейсы.
 * Любой слой зависит только от более внутреннего слоя.
**3. Архитектура проекта должна обладать Высокой когезией (high cohesion):**
 * Каждый класс или модуль отвечает за один аспект игры: например, MiningService только за майнинг, FamilyFacade только за социальные связи.
 * DTO и типы фиксируют контракты между слоями, уменьшая «размазанность» логики.

## 1. Основная идея Архитектуры
## 1.1 Краткий обзор архитектурного решения
 * Архитектрура проекта - Hexagonal / Clean (Ports & Adapters) + Pure Domain Core + тонкие Facades/Adapters.
 * Backend stack: Node.js + TypeScript, Fastify (REST), WebSocket (uWebSockets.js / ws), PostgreSQL + PostGIS; кеш/presence/queue — Redis + BullMQ для фоновых задач.
 * Код должен делиться на чёткие слои: domain (pure), usecases (pure orchestration), adapters (DB/Redis/Storage), facades/controllers (thin orchestrators), api (HTTP/WS handlers).
 * Все побочные эффекты (DB, Redis, filesystem, network) — реализуются только в adapters. domain и usecases — не должны импортировать адаптеры напрямую; они получают интерфейсы (ports) через dependency injection.
 * Чистое ядро (domain) — pure code: алгоритмы мини-игр, анти-чит, расчёты — без side-effects.
 * Facades — thin & transactional: только фасады выполняют side-effects (DB транзакции, publish в Redis, enqueue job). 
 * Small PRs — одна задача = один PR (один фасад/usecase + сопровождающие adapters + тесты). 
 * Не менять domain без Design Doc — любые правки в domain/ требуют design.md, расширенных тестов, и human-approval. 
 * Strict typing & lint: tsconfig.strict = true, ESLint, Prettier.
 * Не импортируем напрямую бизнес-логику — только через абстракции. Например, `useCart()` вместо `import { cart } from '../store/cart'`.
### 1.2 Разделение слоёв и зависимостей
1. Структура слоёв:
 * Домен — сущности, бизнес-правила, основные игровые объекты.
 * Прикладная логика (сервисы) — операции над сущностями, механики игры.
 * Фасады — интерфейс к внешнему миру: API, контроллеры, взаимодействие с базой данных и кэшами.
 * Инфраструктура — база данных, Redis, сторонние библиотеки, хранилища, внешние сервисы.
2. Правило зависимостей:
 * Каждый слой может использовать только слои, находящиеся ниже него (например, фасад может использовать сервисы и домен, но домен не должен зависеть от фасада).
 * Ни один файл не должен импортировать сущности из слоя выше.
 * Любые изменения фасадов должны фиксировать интерфейсы и DTO, чтобы не ломать интеграцию.

## 2. Общие правила для LLM (жёсткие и обязательные)
1. **TDD:** перед добавлением любой новой функциональности желательно создавать юнит-тест, который сначала падает. Затем реализуй минимальный код, чтобы тест прошёл. Тестируй каждый раз при изменении кода. Если успех, переходишь к  рефакторингу.
2. **Малые PR:** одна задача = один PR (изменения ограничены 1 фасадом/1 usecase + связанные adapters + тесты + миграция DB если нужно).
3. **Не менять `domain/*` без процесса:** любые изменения в domain требуют:
 * подробного Design Doc (в PR description) + утверждения человеком;
 * обновление JSON схем/контрактов при необходимости.
 * Type-first / контракт-first: сначала опиши TypeScript-интерфейсы и JSON Schema для входных/выходных DTO/WS-сообщений; LLM генерирует реализацию по этим контрактам.
 * Строгая типизация: tsconfig.strict = true. Все public API файлы экспортируют типы и JSDoc. 
 * Публикация событий: после любого успешного commit-транзакции publish event в Redis (через EventBus adapter).
 * Тесты в CI: PR не может быть смержен, если не прошли unit+integration тесты; интеграция — с тестовым PostGIS и Redis (testcontainers/dev compose).
 * Логирование и метрики: все фасады логируют ключевые события и ошибки; добавлять metric hooks (timings).
 * Deterministic randomness: для мини-игр и loot — использовать seedable RNG, seed берётся из аргумента функции (для тестируемости). 
Добавлять в каждый новый файл в `domain/*` комментарий: `/** DO NOT EDIT WITHOUT DESIGN DOC */`. CI проверяет изменения в domain и требует соответствующий `design.md`.
4. **Types + JSON Schema:** сначала schema, затем code. 
5. **Deterministic behavior:** randomness controlled by seed arg. LLM must expose RNG seed in domain functions. 
6. **Side effects only in facades/adapters.** Domain/usecases must not import adapters.  
7. **Logging & metrics:** include basic log lines and timing (start/end) in facades.
8. **Feature flags:** new behavior deployed behind flags by default.
9. **No global mutable state** in domain/usecases (stateless pure functions).
10. **Follow PR template**

## 3. Структура репозитория (обязательная)
``` bash
/src
  /domain            # pure entities, types, детерминированные алгоритмы, ECS-системы
    /minigames
    /anticheat
    player.ts
  /usecases          # pure orchestration (принимают ports интерфейсы)
    updatePosition.ts
    transferItem.ts
  /adapters          # реализации ports: db, redis, storage, queue
    /db
      pgPlayerRepo.ts
      migrations/
    /cache
      redisPresence.ts
    /storage
      minioStorage.ts
    /queue
      bullMining.ts
  /facades           # thin orchestrators, транзакции, publish events
    playerFacade.ts
    inventoryFacade.ts
    minigameFacade.ts
  /api
    /http
      controllers...
    /ws
      handlers...
  /tests
    /unit
    /integration
    /e2e
  /schemas           # JSON Schema для REST/WS payloads
  /scripts
  /ci
  server.ts
/package.json
/tsconfig.json
/.eslintrc
/docker-compose.yml
/docker-compose.test.yml
```

## 4. Описание слоёв и ответственности (детально)
### 4.1 `domain/` — ядро
 * Содержит чистые функции и структуры данных (entities, value objects), логику мини-игр, алгоритмы анти-чита, расчёты результата майнинга, лут-таблицы.
 * Никаких вызовов DB/Redis/FS.
 * Функции детерминированны: signature (... input, seed?) => output.
 * Тестируется unit & property tests.
### 4.2 `usecases/` — orchestration (pure, где возможно)
 * Использует domain функции и ports (интерфейсы репозиториев), но сам по возможности остаётся pure: возвращает "actions to perform".
 * Не выполняет side-effects сам — возвращает инструкции, которые выполнят facade.
### 4.3 `adapters/` — внешние интеграции
 * Реализация ports: Postgres репозитории, Redis client, MinIO client, Bull workers.
 * Здесь — SQL/ORM, low-level code, миграции.
 * LLM свободно генерирует адаптеры без изменения ядра.
 ### 4.4 `facades/` — thin orchestrators, transactions
 * **Единственная точка**, где разрешено открывать DB-транзакции, выполнять side-effects и публиковать события.
 * Фасад:
    1. получает вход (контроллер/WS),
    2. валидирует (используя JSON Schema / DTO),
    3. вызывает usecase(domain) и получает результат/ инструкцию,
    4. в транзакции DB применяет изменения (если нужно),
    5. после успешного commit — публикует события в Redis / добавляет job в очередь,
    6. возвращает DTO клиенту.
 * **Все фасады должны иметь строго определённые интерфейсы и типы (TypeScript/DTO). Любые изменения сигнатур запрещены без изменения версии фасада.**
 * Тестируется unit и integration (с реальной БД для транзакций).
### 4.5 `api/` — http/ws handlers
 * Преобразует входы в DTO, валидация по JSON Schema, вызывает facade.
 * Не имеет бизнес-логики.

## 5. Соглашения о интерфейсах и DTO (обязательно)
 * Все public DTO описываются TypeScript-интерфейсами и JSON Schema в /src/schemas.
 * WS-сообщения и REST payloads — versioned: player.location.update.v1. При изменении схемы — создаётся .v2 и миграция.
 * LLM обязана генерировать и обновлять JSON Schema вместе с кодом.
Пример DTO (TypeScript):
```
export interface PlayerLocationUpdateV1 {
  playerId: string; // uuid
  lat: number;      // degrees
  lon: number;
  ts: string;       // ISO timestamp
  clientVersion?: string;
}
```
JSON Schema must match that interface and be added to `/src/schemas`.

## 6. WebSocket / events — список основных каналов и схем (обязательное начальное API)
 * `ws:player:location.update.v1` — payload `PlayerLocationUpdateV1`.
 * `ws:minigame:join.v1` — payload `{ roomId, playerId }`.
 * `ws:minigame:input.v1` — `{ roomId, playerId, input, seq }`.
 * `ws:minigame:state.v1` — server -> clients: `{ roomId, state, tick }`.
 * `ws:inventory:transfer.request.v1` — `{ from, to, itemId }`.
 * `ws:inventory:transfer.result.v1` — `{ success, txId? , reason? }`.
Для каждого события — добавить JSON Schema в `/src/schemas` и unit-test, проверяющий что handler валидирует вход по схеме.

## 7. Примеры фасадов — обязательные сигнатуры (TypeScript)
### PlayerFacade (скелет)
```ts
export interface IPlayerFacade {
  updatePosition(payload: PlayerLocationUpdateV1): Promise<void>;
  getProfile(playerId: string): Promise<PlayerDto>;
  // другие методы
}

export class PlayerFacade implements IPlayerFacade {
  constructor(
    private playerRepo: PlayerRepoPort,
    private eventBus: EventBusPort,
    private antiCheat: AntiCheatPort,
    private cache: CachePort,
    private queue: QueuePort
  ) {}

  async updatePosition(payload: PlayerLocationUpdateV1): Promise<void> {
    // 1) validate payload (schema already validated at api layer)
    // 2) call antiCheat.validateMovement (domain/usecase)
    // 3) write short-living location in Redis via cache adapter
    // 4) publish location update via eventBus
    // 5) enqueue job for batched DB write in queue adapter
  }
}
```
Поведение `updatePosition`:
1. antiCheat = usecase(domain) -> score
2. cache.setPresence + cache.setQuickLocation (Redis)
3. eventBus.publish('channel:player:location')
4. enqueue batch write job batch_location_writer (BullMQ)
5. (если cheat score high) repo.setCheatScore(playerId, score) — в транзакции лёгкая запись.

### Обеспечение итоговой консистентности (Eventual Consistency)
Поскольку операция `updatePosition` использует асинхронную очередь для пакетной записи в БД ради максимальной производительности, мы принимаем модель **итоговой консистентности**. Для гарантии того, что данные в конечном итоге будут сохранены, применяется следующий механизм:
1.  **Автоматические повторы (Retries):** Фоновая задача (`job`) в очереди `batch_location_writer` настроена на автоматический повтор в случае сбоя (например, 3 попытки с экспоненциальной задержкой). Это покрывает временные сбои сети или БД.
2.  **Очередь "мертвых писем" (Dead Letter Queue - DLQ):** Если задача не выполнилась после всех попыток, она автоматически перемещается в отдельную очередь `batch_location_writer:failed` для последующего анализа.
3.  **Мониторинг и Логирование:** Наличие задач в DLQ отслеживается системой мониторинга. Любая задача, попавшая в DLQ, **должна быть записана в логи с высоким уровнем критичности (ERROR)** и вызывать немедленное оповещение для команды разработки.

### InventoryFacade (скелет)
```ts
export class InventoryFacade {
  constructor(private db: DbPort, private eventBus: EventBusPort, private repo: InventoryRepoPort) {}

  async transferItem(fromId: string, toId: string, itemId: string): Promise<{ success: boolean; txId?: string }> {
    // MUST perform DB transaction here (db.transaction)
    // 1) check ownership, slot, limits
    // 2) remove item from fromId, add to toId
    // 3) log transfer
    // 4) commit
    // 5) publish 'inventory.transfer' via eventBus
  }
}
```
**Обязательное правило:** Side-effect operations (DB update, publish) — только в фасадах и adapters. `domain/usecases` — только pure transformations.
Поведение: **обязательная DB транзакция:** verify ownership, check validity, delete/add item rows, insert transfer log, commit, publish event.

## 8. БД — стартовый DDL (Postgres + PostGIS)
(использовать в миграциях; миграции — в `/src/adapters/db/migrations`)
```sql
CREATE EXTENSION IF NOT EXISTS postgis;

-- players
CREATE TABLE players (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  tg_id bigint UNIQUE,
  nickname text,
  last_location geometry(Point,4326),
  last_seen timestamptz,
  experience_hours integer DEFAULT 0,
  cheating_score numeric DEFAULT 0,
  is_valid boolean DEFAULT TRUE,
  created_at timestamptz DEFAULT now()
);

-- spots
CREATE TABLE spots (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  name text,
  geom geometry(Point,4326),
  radius_meters integer,
  type text,
  metadata jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now()
);
CREATE INDEX idx_spots_geom ON spots USING GIST (geom);

-- inventory items (универсальная модель предметов)
CREATE TABLE inventory_items (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid REFERENCES players(id),
  slot smallint,
  item_type text NOT NULL, -- 'resource','artifact','dataset','chip', etc.
  item_meta jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now()
);
CREATE INDEX idx_inventory_owner ON inventory_items(owner_id);

-- transfers log
CREATE TABLE transfers (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  from_player uuid REFERENCES players(id),
  to_player uuid REFERENCES players(id),
  item_id uuid REFERENCES inventory_items(id),
  created_at timestamptz DEFAULT now()
);

-- datasets (игровой предмет, не файлы)
CREATE TABLE datasets (
  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
  owner_id uuid REFERENCES players(id),
  game_type text NOT NULL,
  minutes integer DEFAULT 0,
  sessions integer DEFAULT 0,
  rarity text DEFAULT 'common',
  meta jsonb DEFAULT '{}'::jsonb,
  created_at timestamptz DEFAULT now(),
  updated_at timestamptz DEFAULT now()
);
CREATE INDEX idx_datasets_owner_game ON datasets(owner_id, game_type);
```

## 9. Redis — ключевые схемы (обязательные)
 * Presence: `presence:player:{playerId}` = '1' EX 45
 * Quick location: `player:location:{playerId}` = HASH {lat, lon, ts} EX 90
 * Pub/Sub channels: `channel:player:location`, `channel:minigame:{roomId}`, `channel:inventory:transfer`
 * Queues via BullMQ: `bull:queue:mining`, `bull:queue:batch_location_writer`, `repair_spot`
 * Leaderboards: `z:leaderboard:experience`
LLM генерирует работу с Redis только в `adapters/queue/cache`.
`adapters/cache/redisPresence.ts` реализует операции setPresence, getOnlineInRegion, etc.

## 10. Тестирование — правила и настройки (обязательное)
 * **Unit tests:** быстрые, мокают adapters. Framework: Vitest или Jest.
 * **Integration tests:** с реальным Postgres+PostGIS и Redis (docker-compose.test.yml или testcontainers). Integration tests должны проверять транзакции, spatial queries и взаимодействие фасадов с adapters.
 * **E2E:** ограниченный набор сценариев (создание семьи, майнинг + transfer flow, тренировка NPU). Использовать *Playwright / node ws client.
 * **Property tests:** анти-чит — генерировать множество треков и проверять invariants (speed, teleport). Fast-check (JS)рекомендован.
* **Coverage:** минимум 80% для domain & usecases. CI блокирует merge ниже этого порога.
 * **Mutation testing:** запускать периодически (Stryker) для проверки качества тестов.

## 11. CI / PR requirements (обязательное)
1. `npm run lint` (ESLint + Prettier) — надо проходить. 
2. `npm run typecheck` (tsc --noEmit). 
3. `npm test:unit` (fast). 
4. `npm test:integration` (uses docker-compose.test or testcontainers). 
5. `npm run build`. 
6. coverage upload, check threshold. 
7. PR must contain: 
 * короткое описание изменений;
 * перечень новых/изменённых тестов;
 * если изменены схемы — JSON Schema diff;
 * если изменены доменные правила — файл design.md в PR (mandatory).
8. Merge only after at least one human review (you or designated reviewer).

## 12. Code style / lint / formatting (обязательно)
 * TypeScript with strict types.
 * ESLint rules: Airbnb or equivalent + no-explicit-any; no // @ts-ignore in merged code.
 * Prettier config fixed.
 * Commit messages: Conventional Commits (feat:, fix:, chore:, test:).
 * PR title: [feat] краткое описание / [fix].

## 13. PR template (LLM must fill)
1. Title: `[type] short-summary`
2. Description:
 * What changed (short).
 * Why (motivation).
 * Tests added/modified.
 * Schema changes (if any) + link to JSON Schema file.
 * Migration scripts (if DB changed) — path to migration.
 * How to run locally (commands).
 * Risks and rollbacks.

## 14. How LLM should produce code — step-by-step recipe (strict)
1. **Write failing unit test(s)** in `/src/tests/unit` covering new behavior (use mocks for adapters).
2. **Implement minimal domain/usecase** code to make test pass. Domain first.
3. **Write adapter mocks** if needed; run unit tests.
4. **Implement adapter(s)** if integration required (DB migrations + repo implementations). Add migration file in `adapters/db/migrations`.
5. **Write integration test** (docker-compose.test.yml must be used) verifying DB+Redis behavior.
6. **Write facade** that orchestrates DB transaction and publish events.
7. **Add JSON Schema** for payloads and update `/src/schemas`.
8. **Add API handler** (http/ws) which validates payload by schema and calls facade.
9. **Run full test suite**. If green — prepare PR with required description and CI artifacts.
10. **Do not modify any other modules** outside the scope defined, unless explicitly requested and with human approval.

## 15. Example: процесс создания одного концептуального PR (пример)
 Task: добавить endpoint POST `/player/location` (v1) чтобы обновлять позицию.
 Steps LLM must do (and include in PR):
1. Add JSON Schema `/src/schemas/player.location.update.v1.json`.
2. Add unit-test `/src/tests/unit/playerFacade.updatePosition.spec.ts` (mock PlayerRepo, AntiCheat, Cache, EventBus). Test asserts calls and behavior for clean & cheat cases. (Failing at first).
3. Implement `domain/anticheat.validateMovement` (pure function) + unit tests.
4. Implement `usecases/updatePosition.ts` that calls anticheat and returns actions.
5. Implement `adapters/cache/redisPresence.ts` stub (if absent) and tests for adapter.
6. Implement `facades/playerFacade.updatePosition` calling usecase, performing Redis writes via adapter, publishing event, enqueue batch write.
7. Add `api/http/controllers/player.ts` to expose endpoint, validate payload, call facade.
8. Add integration test that starts test Postgres+Redis, calls endpoint, asserts Redis keys and enqueued job.
9. Add migration if DB schema changed (none here).
10. Run tests, ensure green. Prepare PR description.

## 16. Доп. защитные меры (чтобы LLM не ломал код)
 * **Contract tests:** для каждого модифицированного adapter/facade — автогенерировать JSON Schema и тесты соответствия.
 * **Feature flag:** если LLM меняет поведение, по умолчанию ставить behind feature-flag.
 * **Immutable domain:** большинство domain-файлов должны иметь заголовок /** DO NOT EDIT WITHOUT DESIGN DOC */ и защищаться RULE: PR must include design.md for any change.
 * **Run static analysis:** Snyk/Dep check + linter.

## 17. Шаблоны файлов (примеры) — LLM обязана следовать
### Пример unit-test (vitest/jest style)
```ts
import { PlayerFacade } from '../../facades/playerFacade';
import { createPlayerRepoMock, createCacheMock, createEventBusMock } from '../mocks';

it('publishes location and enqueues DB write', async () => {
  const repo = createPlayerRepoMock();
  const cache = createCacheMock();
  const eventBus = createEventBusMock();
  const antiCheat = { validateMovement: vi.fn().mockResolvedValue(0.1) };
  const facade = new PlayerFacade(repo, eventBus, antiCheat, cache, /*queue*/);

  await facade.updatePosition({ playerId: 'p1', lat: 1, lon: 2, ts: new Date().toISOString()});

  expect(cache.setPresence).toHaveBeenCalledWith('p1', expect.any(Number));
  expect(eventBus.publish).toHaveBeenCalledWith('player.location.updated', expect.any(Object));
});
```
### Пример migration filename
```swift
src/adapters/db/migrations/20250906_create_players_spots.sql
```

## 18. Документы, которые LLM должен генерировать при крупных изменениях
 * `docs/design/<feature>-design.md` — описание изменения, схемы, примеры сценариев, backward-compatibility plan.
 * `docs/contracts/<event>-v1.json` — JSON Schema.
 * `CHANGELOG.md` entry.

## 19. Operational / Run commands (для README и CI)
 * `npm ci`
 * `npm run build`
 * `npm run lint`
 * `npm run typecheck`
 * `npm test` (unit + integration)
 * `docker-compose up -d` (dev)
 * `docker-compose -f docker-compose.test.yml up --build` (integration test infra)


