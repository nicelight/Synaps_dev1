
# Архитектура проекта "Synaps" и требования по разработке кода. 
**1. Архитектура проекта ориентирована на безопасность изменений кода** при генерации кода LLM моделью: тонкие фасады + pure domain + контракт-first + Spec Driven Dev  + CI + small-PRs.
**2. Архитектура проекта должна обладать Низкой связанностью (low coupling):**
 * Каждый модуль/фасад имеет отдельную ответственность.
 * Сервисы и домен не знают про инфраструктуру напрямую — используют фасады и интерфейсы.
 * Любой слой зависит только от более внутреннего слоя.
**3. Архитектура проекта должна обладать Высокой когезией (high cohesion):**
 * Каждый класс или модуль отвечает за один аспект игры: например, MiningService только за майнинг, FamilyFacade только за социальные связи.
 * DTO и типы фиксируют контракты между слоями, уменьшая «размазанность» логики.

## 1. Основная идея Архитектуры
## 1.1 Краткий обзор архитектурного решения
 * Архитектрура проекта - Hexagonal / Clean (Ports & Adapters) + Pure Domain Core + тонкие Facades/Adapters.
 * Backend stack: Node.js + TypeScript, Fastify (REST), WebSocket (uWebSockets.js / ws), PostgreSQL + PostGIS; кеш/presence/queue — Redis + BullMQ для фоновых задач.
 * Код должен делиться на чёткие слои: domain (pure), usecases (pure orchestration), adapters (DB/Redis/Storage), facades/controllers (thin orchestrators), api (HTTP/WS handlers).
 * Все побочные эффекты (DB, Redis, filesystem, network) — реализуются только в adapters. domain и usecases — не должны импортировать адаптеры напрямую; они получают интерфейсы (ports) через dependency injection.
 * Чистое ядро (domain) — pure code: алгоритмы мини-игр, анти-чит, расчёты — без side-effects.
 * Facades — thin & transactional: только фасады выполняют side-effects (DB транзакции, publish в Redis, enqueue job). 
 * Small PRs — одна задача = один PR (один фасад/usecase + сопровождающие adapters + тесты). 
 * Не менять domain без Design Doc — любые правки в domain/ требуют design.md, расширенных тестов, и human-approval. 
 * Strict typing & lint: tsconfig.strict = true, ESLint, Prettier.
 * Не импортируем напрямую бизнес-логику — только через абстракции. Например, `useCart()` вместо `import { cart } from '../store/cart'`.
### 1.2 Разделение слоёв и зависимостей
1. Структура слоёв:
 * Домен — сущности, бизнес-правила, основные игровые объекты.
 * Прикладная логика (сервисы) — операции над сущностями, механики игры.
 * Фасады — интерфейс к внешнему миру: API, контроллеры, взаимодействие с базой данных и кэшами.
 * Инфраструктура — база данных, Redis, сторонние библиотеки, хранилища, внешние сервисы.
2. Правило зависимостей:
 * Каждый слой может использовать только слои, находящиеся ниже него (например, фасад может использовать сервисы и домен, но домен не должен зависеть от фасада).
 * Ни один файл не должен импортировать сущности из слоя выше.
 * Любые изменения фасадов должны фиксировать интерфейсы и DTO, чтобы не ломать интеграцию.

## 2. Общие правила для LLM (жёсткие и обязательные)
1. **TDD:** перед добавлением любой новой функциональности желательно создавать юнит-тест, который сначала падает. Затем реализуй минимальный код, чтобы тест прошёл. Тестируй каждый раз при изменении кода. Если успех, переходишь к  рефакторингу.
2. **Малые PR:** одна задача = один PR (изменения ограничены 1 фасадом/1 usecase + связанные adapters + тесты + миграция DB если нужно).
3. **Не менять `domain/*` без процесса:** любые изменения в domain требуют:
 * подробного Design Doc (в PR description) + утверждения человеком;
 * обновление JSON схем/контрактов при необходимости.
 * Type-first / контракт-first: сначала опиши TypeScript-интерфейсы и JSON Schema для входных/выходных DTO/WS-сообщений; LLM генерирует реализацию по этим контрактам.
 * Строгая типизация: tsconfig.strict = true. Все public API файлы экспортируют типы и JSDoc. 
 * Публикация событий: после любого успешного commit-транзакции publish event в Redis (через EventBus adapter).
 * Тесты в CI: PR не может быть смержен, если не прошли unit+integration тесты; интеграция — с тестовым PostGIS и Redis (testcontainers/dev compose).
 * Логирование и метрики: все фасады логируют ключевые события и ошибки; добавлять metric hooks (timings).
 * Deterministic randomness: для мини-игр и loot — использовать seedable RNG, seed берётся из аргумента функции (для тестируемости). 
Добавлять в каждый новый файл в `domain/*` комментарий: `/** DO NOT EDIT WITHOUT DESIGN DOC */`. CI проверяет изменения в domain и требует соответствующий `design.md`.
4. **Types + JSON Schema:** сначала schema, затем code. 
5. **Deterministic behavior:** randomness controlled by seed arg. LLM must expose RNG seed in domain functions. 
6. **Side effects only in facades/adapters.** Domain/usecases must not import adapters.  
7. **Logging & metrics:** include basic log lines and timing (start/end) in facades.
8. **Feature flags:** new behavior deployed behind flags by default.
9. **No global mutable state** in domain/usecases (stateless pure functions).
10. **Follow PR template**

## 3. Структура репозитория (обязательная)
*TODO*

## 4. Описание слоёв и ответственности (детально)
### 4.1 `domain/` — ядро
 * Содержит чистые функции и структуры данных (entities, value objects), логику мини-игр, алгоритмы анти-чита, расчёты результата майнинга, лут-таблицы.
 * Никаких вызовов DB/Redis/FS.
 * Функции детерминированны: signature (... input, seed?) => output.
 * Тестируется unit & property tests.
### 4.2 `usecases/` — orchestration (pure, где возможно)
 * Использует domain функции и ports (интерфейсы репозиториев), но сам по возможности остаётся pure: возвращает "actions to perform".
 * Не выполняет side-effects сам — возвращает инструкции, которые выполнят facade.
### 4.3 `adapters/` — внешние интеграции
 * Реализация ports: Postgres репозитории, Redis client, MinIO client, Bull workers.
 * Здесь — SQL/ORM, low-level code, миграции.
 * LLM свободно генерирует адаптеры без изменения ядра.
 ### 4.4 `facades/` — thin orchestrators, transactions
 * **Единственная точка**, где разрешено открывать DB-транзакции, выполнять side-effects и публиковать события.
 * Фасад:
    1. получает вход (контроллер/WS),
    2. валидирует (используя JSON Schema / DTO),
    3. вызывает usecase(domain) и получает результат/ инструкцию,
    4. в транзакции DB применяет изменения (если нужно),
    5. после успешного commit — публикует события в Redis / добавляет job в очередь,
    6. возвращает DTO клиенту.
 * **Все фасады должны иметь строго определённые интерфейсы и типы (TypeScript/DTO). Любые изменения сигнатур запрещены без изменения версии фасада.**
 * Тестируется unit и integration (с реальной БД для транзакций).
### 4.5 `api/` — http/ws handlers
 * Преобразует входы в DTO, валидация по JSON Schema, вызывает facade.
 * Не имеет бизнес-логики.

## 5. Соглашения о интерфейсах и DTO (обязательно)
 * Все public DTO описываются TypeScript-интерфейсами и JSON Schema в /src/schemas.
 * WS-сообщения и REST payloads — versioned: player.location.update.v1. При изменении схемы — создаётся .v2 и миграция.
 * LLM обязана генерировать и обновлять JSON Schema вместе с кодом.
Пример DTO (TypeScript):
```
export interface PlayerLocationUpdateV1 {
  playerId: string; // uuid
  lat: number;      // degrees
  lon: number;
  ts: string;       // ISO timestamp
  clientVersion?: string;
}
```
JSON Schema must match that interface and be added to `/src/schemas`.

## 6. WebSocket / events — список основных каналов и схем (обязательное начальное API)
*TODO*
Для каждого события — добавить JSON Schema в `/src/schemas` и unit-test, проверяющий что handler валидирует вход по схеме.

## 7. Примеры фасадов — обязательные сигнатуры (TypeScript)
*TODO*

**Обязательное правило:** Side-effect operations (DB update, publish) — только в фасадах и adapters. `domain/usecases` — только pure transformations.
Поведение: **обязательная DB транзакция:** verify ownership, check validity, delete/add item rows, insert transfer log, commit, publish event.

## 8. БД — стартовый DDL (Postgres + PostGIS)
*TODO*

## 9. Redis — ключевые схемы (обязательные)
*TODO*

## 10. Тестирование — правила и настройки (обязательное)
 * **Unit tests:** быстрые, мокают adapters. Framework: Vitest или Jest.
 * **Integration tests:** с реальным Postgres+PostGIS и Redis (docker-compose.test.yml или testcontainers). Integration tests должны проверять транзакции, spatial queries и взаимодействие фасадов с adapters.
 * **E2E:** ограниченный набор сценариев (создание семьи, майнинг + transfer flow, тренировка NPU). Использовать *Playwright / node ws client.
 * **Property tests:** анти-чит — генерировать множество треков и проверять invariants (speed, teleport). Fast-check (JS)рекомендован.
* **Coverage:** минимум 80% для domain & usecases. CI блокирует merge ниже этого порога.
 * **Mutation testing:** запускать периодически (Stryker) для проверки качества тестов.

## 11. CI / PR requirements
*TODO*
 PR must contain: 
 * короткое описание изменений;
 * перечень новых/изменённых тестов;
 * если изменены схемы — JSON Schema diff;
 * если изменены доменные правила — файл design.md в PR (mandatory).
Merge only after at least one human review (you or designated reviewer).

## 12. Code style / lint / formatting (обязательно)
 * TypeScript with strict types.
 * ESLint rules: Airbnb or equivalent + no-explicit-any; no // @ts-ignore in merged code.
 * Prettier config fixed.
 * Commit messages: Conventional Commits (feat:, fix:, chore:, test:).
 * PR title: [feat] краткое описание / [fix].

## 13. PR template (LLM must fill)
*TODO*
1. Title: `[type] short-summary`
2. Description:
 * What changed (short).
 * Why (motivation).
 * Tests added/modified.
 * Schema changes (if any) + link to JSON Schema file.
 * Migration scripts (if DB changed) — path to migration.
 * How to run locally (commands).
 * Risks and rollbacks.

## 14. How LLM should produce code — step-by-step recipe (strict)
**Do not modify any other modules** outside the scope defined, unless explicitly requested and with human approval.
### 14.1 In case if required TDD
1. **Write failing unit test(s)** in `/src/tests/unit` covering new behavior (use mocks for adapters).
2. **Implement minimal domain/usecase** code to make test pass. Domain first.
3. **Write adapter mocks** if needed; run unit tests.
4. **Implement adapter(s)** if integration required (DB migrations + repo implementations). Add migration file in `adapters/db/migrations`.
5. **Write integration test** (docker-compose.test.yml must be used) verifying DB+Redis behavior.
6. **Write facade** that orchestrates DB transaction and publish events.
7. **Add JSON Schema** for payloads and update `/src/schemas`.
8. **Add API handler** (http/ws) which validates payload by schema and calls facade.
9. **Run full test suite**. If green — prepare PR with required description and CI artifacts.

## 15. Example: процесс создания одного концептуального PR (пример)
 ### TDD case
 Task: добавить endpoint POST `/player/location` (v1) чтобы обновлять позицию.
 Steps LLM must do (and include in PR):
1. Add JSON Schema `/src/schemas/player.location.update.v1.json`.
2. Add unit-test `/src/tests/unit/playerFacade.updatePosition.spec.ts` (mock PlayerRepo, AntiCheat, Cache, EventBus). Test asserts calls and behavior for clean & cheat cases. (Failing at first).
3. Implement `domain/anticheat.validateMovement` (pure function) + unit tests.
4. Implement `usecases/updatePosition.ts` that calls anticheat and returns actions.
5. Implement `adapters/cache/redisPresence.ts` stub (if absent) and tests for adapter.
6. Implement `facades/playerFacade.updatePosition` calling usecase, performing Redis writes via adapter, publishing event, enqueue batch write.
7. Add `api/http/controllers/player.ts` to expose endpoint, validate payload, call facade.
8. Add integration test that starts test Postgres+Redis, calls endpoint, asserts Redis keys and enqueued job.
9. Add migration if DB schema changed (none here).
10. Run tests, ensure green. Prepare PR description.

## 16. Доп. защитные меры (чтобы LLM не ломал код)
 * **Contract tests:** для каждого модифицированного adapter/facade — автогенерировать JSON Schema и тесты соответствия.
 * **Feature flag:** если LLM меняет поведение, по умолчанию ставить behind feature-flag.
 * **Immutable domain:** большинство domain-файлов должны иметь заголовок /** DO NOT EDIT WITHOUT DESIGN DOC */ и защищаться RULE: PR must include design.md for any change.
 * **Run static analysis:** Snyk/Dep check + linter.

## 17. Шаблоны файлов (примеры) — LLM обязана следовать
*TODO*

## 18. Документы, которые LLM должен генерировать при крупных изменениях
 * `docs/design/<feature>-design.md` — описание изменения, схемы, примеры сценариев, backward-compatibility plan.
 * `docs/contracts/<event>-v1.json` — JSON Schema.
 * `CHANGELOG.md` entry.
